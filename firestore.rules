/**
 * @fileoverview Firestore Security Rules for Primavera Delivery application.
 *
 * Core Philosophy:
 * This ruleset enforces a hybrid security model. User data is strictly protected
 * by ownership, while product information is publicly readable but admin-writeable.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible only to the owning user.
 * - /productGroups/{productGroupId}: Product categories, publicly readable but
 *   modifiable only by admins.
 * - /products/{productId}: Product details, publicly readable but modifiable only
 *   by admins.  Products are linked to product groups via the `groupId` field.
 * - /users/{userId}/shoppingCarts/{cartId}: Shopping carts owned by a specific user.
 * - /users/{userId}/shoppingCarts/{cartId}/cartItems/{cartItemId}: Items within a user's cart.
 * - /users/{userId}/orders/{orderId}: Orders placed by a specific user.
 * - /orders/{orderId}/orderItems/{orderItemId}: Items within an order.
 * - /orders/{orderId}/payments/{paymentId}: Payment information for an order.
 * - /roles_admin/{uid}:  Admin role assignments. Document existence grants admin role.
 *
 * Key Security Decisions:
 * - User listing is disallowed for privacy.
 * - Public read access is granted to product-related data to allow browsing
 *   without authentication.
 *
 * Denormalization for Authorization:
 * - The `products` collection denormalizes the `groupId` to allow for efficient
 *   filtering and rule simplicity.  Admin status is checked via the
 *   `isAdmin()` function, which checks for the existence of a document in the
 *   `/roles_admin/{uid}` collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Authentication required for most operations.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the resource, based on the provided userId.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Ownership is determined by matching the authenticated user's UID to the resource's userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the owner of the resource and that the resource exists.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Combines ownership check with resource existence for destructive operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the user has admin privileges by verifying the existence
     *              of a document in the `/roles_admin/{uid}` collection.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Admin privileges are granted by document existence in the roles_admin collection.
     */
    function isAdmin() {
        return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description Rules for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' creates their own profile.
     *          request.auth.uid == 'user123' && request.resource.data.id == 'user123'
     * @allow (get, update, delete) User with UID 'user123' accesses their own profile.
     *          request.auth.uid == 'user123'
     * @deny (create) User with UID 'user123' attempts to create a profile for another user 'user456'.
     *          request.auth.uid == 'user123' && request.resource.data.id == 'user456'
     * @deny (list) Any user attempts to list all users.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /productGroups/{productGroupId} collection.
     * @path /productGroups/{productGroupId}
     * @allow (get, list) Any user can read product groups.
     * @allow (create, update, delete) Only admins can modify product groups.
     * @deny (create, update, delete) Non-admin user attempts to modify product groups.
     * @principle Public read access with admin-only writes for product groups.
     */
    match /productGroups/{productGroupId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Rules for the /products/{productId} collection.
     * @path /products/{productId}
     * @allow (get, list) Any user can read products.
     * @allow (create, update, delete) Only admins can modify products.
     * @deny (create, update, delete) Non-admin user attempts to modify products.
     * @principle Public read access with admin-only writes for products.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Rules for the /users/{userId}/shoppingCarts/{cartId} collection.
     * @path /users/{userId}/shoppingCarts/{cartId}
     * @allow (create, get, update, delete) Only the owner user can manage their shopping cart.
     * @deny (create, get, update, delete) Other users cannot manage someone else's shopping cart.
     * @deny (list) Any user attempts to list all shopping carts.
     * @principle Enforces document ownership for shopping carts.
     */
    match /users/{userId}/shoppingCarts/{cartId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId && request.resource.data.id == cartId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/shoppingCarts/{cartId}/cartItems/{cartItemId} collection.
     * @path /users/{userId}/shoppingCarts/{cartId}/cartItems/{cartItemId}
     * @allow (create, get, update, delete) Only the owner user can manage items in their shopping cart.
     * @deny (create, get, update, delete) Other users cannot manage items in someone else's shopping cart.
     * @deny (list) Any user attempts to list all cart items.
     * @principle Enforces ownership inherited from the parent shopping cart.
     */
    match /users/{userId}/shoppingCarts/{cartId}/cartItems/{cartItemId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.shoppingCartId == cartId;
      allow update: if isExistingOwner(userId) && request.resource.data.shoppingCartId == cartId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/orders/{orderId} collection.
     * @path /users/{userId}/orders/{orderId}
     * @allow (create, get, update, delete) Only the owner user can manage their orders.
     * @deny (create, get, update, delete) Other users cannot manage someone else's orders.
     * @deny (list) Any user attempts to list all orders.
     * @principle Enforces document ownership for orders.
     */
    match /users/{userId}/orders/{orderId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId && request.resource.data.id == orderId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /orders/{orderId}/orderItems/{orderItemId} collection.
     * @path /orders/{orderId}/orderItems/{orderItemId}
     * @allow (create, get, update, delete) Anyone can manage order items for now. // TODO: Review security for OrderItems
     * @deny (list) Any user attempts to list all order items.
     */
    match /orders/{orderId}/orderItems/{orderItemId} {
      allow get: if true;
      allow list: if false;
      allow create: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if resource != null; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if resource != null; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for the /orders/{orderId}/payments/{paymentId} collection.
     * @path /orders/{orderId}/payments/{paymentId}
     * @allow (create, get, update, delete) Anyone can manage payments for now.  // TODO: Review security for Payments
     * @deny (list) Any user attempts to list all payments.
     */
    match /orders/{orderId}/payments/{paymentId} {
      allow get: if true;
      allow list: if false;
      allow create: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if resource != null; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if resource != null; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for the /roles_admin/{uid} collection.
     * @path /roles_admin/{uid}
     * @allow (get) Only the admin user can retrieve their own admin document.
     * @allow (create) Only a service account can create admin documents. // TODO: implement service account
     * @deny (list, update, delete) Listing, updating, and deleting admin documents is prohibited.
     * @principle Admin privileges are managed through document existence.
     */
    match /roles_admin/{uid} {
        allow get: if isAdmin();
        allow list: if false;
        allow create: if false; // TODO: implement service account.
        allow update: if false;
        allow delete: if false;
    }
  }
}